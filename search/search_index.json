{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 \ud83d\udd25 FastAPI Auto Generate Gateway \u00b6 A library that allows you to automate the process of creating an API Gateway \ud83d\udcda About \u00b6 This is a library that enables the automation of the process of creating an API Gateway. With its help, you can quickly and easily configure and deploy an API Gateway for your microservices architecture. The library provides a simple and intuitive interface for configuration, which reduces the time and effort required to manually set up the API Gateway. \ud83d\udee0\ufe0f Installation \u00b6 To install fastapi-gateway-auto-generate : pip install fastapi-gateway-auto-generate","title":"Overview"},{"location":"#overview","text":"","title":"Overview"},{"location":"#fastapi-auto-generate-gateway","text":"A library that allows you to automate the process of creating an API Gateway","title":"\ud83d\udd25 FastAPI Auto Generate Gateway"},{"location":"#about","text":"This is a library that enables the automation of the process of creating an API Gateway. With its help, you can quickly and easily configure and deploy an API Gateway for your microservices architecture. The library provides a simple and intuitive interface for configuration, which reduces the time and effort required to manually set up the API Gateway.","title":"\ud83d\udcda About"},{"location":"#installation","text":"To install fastapi-gateway-auto-generate : pip install fastapi-gateway-auto-generate","title":"\ud83d\udee0\ufe0f Installation"},{"location":"FAQ/","text":"FAQ \u00b6 Where is the service data stored? \u00b6 Data and service status are stored in a local SQLite database. If you want to store the database side by side, you can specify an additional parameter database_path","title":"FAQ"},{"location":"FAQ/#faq","text":"","title":"FAQ"},{"location":"FAQ/#where-is-the-service-data-stored","text":"Data and service status are stored in a local SQLite database. If you want to store the database side by side, you can specify an additional parameter database_path","title":"Where is the service data stored?"},{"location":"CodeReference/","text":"fastapi_gateway_auto_generate.Generator \u00b6 Generator ( config ) \u00b6 The class responsible for adding automatic service connections to the FastAPI object. Parameters: Name Type Description Default config Config The Config object with its configuration. required Source code in fastapi_gateway_auto_generate/Generator.py 13 14 15 16 17 18 19 20 21 22 def __init__ ( self , config : Config ) -> None : self . __config = config if not os . path . isfile ( self . __config . db_path ): InitDatabaseUsecase () . execute ( db_url = config . db_url , db_path = config . db_path ) if self . __config . service_management : self . __init_management_urls () self . build () __init_management_urls () \u00b6 Service management initialization. Source code in fastapi_gateway_auto_generate/Generator.py 24 25 26 27 def __init_management_urls ( self ): \"\"\"Service management initialization. \"\"\" Management ( config = self . __config ) build () \u00b6 Adding services to the FastAPI object. Source code in fastapi_gateway_auto_generate/Generator.py 29 30 31 32 33 34 35 36 37 38 39 40 def build ( self ) -> None : \"\"\"Adding services to the FastAPI object. \"\"\" services_result = BuildRouteModelsUsecase () . execute ( config = self . __config ) BuildRoutesUsecase () . execute ( services_result = services_result , fast_api_app = self . __config . fast_api_app ) fastapi_gateway_auto_generate.Config \u00b6 Config ( fast_api_app , service_management = True , db_path = './' , db_name = 'database' , jwt = None , allow_large_files = False , broker_url = '' ) \u00b6 The Configuration class is intended for configuring the auto-generation of services for the API Gateway. Parameters: Name Type Description Default fast_api_app FastAPI Pointer to your FastAPI application. required service_management bool Enable the built-in service manager. True db_path str The path to the SQLite database. './' jwt Optional [ Type [ T ]] The class responsible for protecting the routers. None celery_app Optional [ Celery ] The Celery object responsible for transferring large files. required Source code in fastapi_gateway_auto_generate/Config.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def __init__ ( self , fast_api_app : FastAPI , service_management : bool = True , db_path : str = \"./\" , db_name : str = \"database\" , jwt : Optional [ Type [ T ]] = None , allow_large_files : bool = False , broker_url : str = \"\" ) -> None : self . fast_api_app : FastAPI = fast_api_app self . service_management : bool = service_management self . jwt = jwt self . service_name = \"API-Gateway\" if db_name != \"database\" : self . db_name = db_name else : self . db_name = \"database\" if db_path != \"./\" : self . db_path = db_path else : self . db_path = \"./\" # self.db_path = \"./database.db\" if db_path is None else db_path self . db_url = f \"sqlite:/// { self . get_database_absolute_path () } \" # try: # if not (allow_large_files and broker_url): # raise ConfigException(\"Broker URL was not specified\") # except Exception as e: # RichTraceback().console_call_exception() self . allow_large_files : bool = allow_large_files Warning The service_management parameter is temporarily not functioning and will always be set to True .","title":"Main"},{"location":"CodeReference/#fastapi_gateway_auto_generate.Generator","text":"","title":"Generator"},{"location":"CodeReference/#fastapi_gateway_auto_generate.Generator.Generator","text":"The class responsible for adding automatic service connections to the FastAPI object. Parameters: Name Type Description Default config Config The Config object with its configuration. required Source code in fastapi_gateway_auto_generate/Generator.py 13 14 15 16 17 18 19 20 21 22 def __init__ ( self , config : Config ) -> None : self . __config = config if not os . path . isfile ( self . __config . db_path ): InitDatabaseUsecase () . execute ( db_url = config . db_url , db_path = config . db_path ) if self . __config . service_management : self . __init_management_urls () self . build ()","title":"Generator"},{"location":"CodeReference/#fastapi_gateway_auto_generate.Generator.Generator.__init_management_urls","text":"Service management initialization. Source code in fastapi_gateway_auto_generate/Generator.py 24 25 26 27 def __init_management_urls ( self ): \"\"\"Service management initialization. \"\"\" Management ( config = self . __config )","title":"__init_management_urls()"},{"location":"CodeReference/#fastapi_gateway_auto_generate.Generator.Generator.build","text":"Adding services to the FastAPI object. Source code in fastapi_gateway_auto_generate/Generator.py 29 30 31 32 33 34 35 36 37 38 39 40 def build ( self ) -> None : \"\"\"Adding services to the FastAPI object. \"\"\" services_result = BuildRouteModelsUsecase () . execute ( config = self . __config ) BuildRoutesUsecase () . execute ( services_result = services_result , fast_api_app = self . __config . fast_api_app )","title":"build()"},{"location":"CodeReference/#fastapi_gateway_auto_generate.Config","text":"","title":"Config"},{"location":"CodeReference/#fastapi_gateway_auto_generate.Config.Config","text":"The Configuration class is intended for configuring the auto-generation of services for the API Gateway. Parameters: Name Type Description Default fast_api_app FastAPI Pointer to your FastAPI application. required service_management bool Enable the built-in service manager. True db_path str The path to the SQLite database. './' jwt Optional [ Type [ T ]] The class responsible for protecting the routers. None celery_app Optional [ Celery ] The Celery object responsible for transferring large files. required Source code in fastapi_gateway_auto_generate/Config.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def __init__ ( self , fast_api_app : FastAPI , service_management : bool = True , db_path : str = \"./\" , db_name : str = \"database\" , jwt : Optional [ Type [ T ]] = None , allow_large_files : bool = False , broker_url : str = \"\" ) -> None : self . fast_api_app : FastAPI = fast_api_app self . service_management : bool = service_management self . jwt = jwt self . service_name = \"API-Gateway\" if db_name != \"database\" : self . db_name = db_name else : self . db_name = \"database\" if db_path != \"./\" : self . db_path = db_path else : self . db_path = \"./\" # self.db_path = \"./database.db\" if db_path is None else db_path self . db_url = f \"sqlite:/// { self . get_database_absolute_path () } \" # try: # if not (allow_large_files and broker_url): # raise ConfigException(\"Broker URL was not specified\") # except Exception as e: # RichTraceback().console_call_exception() self . allow_large_files : bool = allow_large_files Warning The service_management parameter is temporarily not functioning and will always be set to True .","title":"Config"},{"location":"CodeReference/database/","text":"","title":"Database"},{"location":"CodeReference/migration/","text":"","title":"Migration"},{"location":"CodeReference/domain/models/RouteModel/","text":"fastapi_gateway_auto_generate.domain.models.RouteModel.RouteModel dataclass \u00b6 A data class for storing data about a microservice. Parameters: Name Type Description Default request_method Any Is a callable (like app.get, app.post and so on.) required gateway_path str Is the path to bind gateway. required service_url str Is url path to microservice (like \" https://api.example.com/v1 \") required service_path str The path to the endpoint on another service. required query_params Optional [ List [ str ]] Used to extract query parameters from endpoint and transmission to microservice None query_required Optional [ List [ bool ]] Defines whether the specified parameters are mandatory for the request to the microservice. None query_is_cookie Optional [ List [ bool ]] Determines whether the specified parameters should be passed as a cookie. None form_params Optional [ List [ str ]] Used to extract form model parameters from endpoint and transmission to microservice None body_params Optional [ List [ str ]] Used to extract body model from endpoint and transmission to microservice None tags Optional [ List [ str ]] Allows grouped objects in the api docs None dependencies Optional [ str ] See documentation for details - https://fastapi.tiangolo.com/tutorial/dependencies/#declare-the-dependency-in-the-dependant None","title":"RouteModel"},{"location":"CodeReference/domain/models/RouteModel/#fastapi_gateway_auto_generate.domain.models.RouteModel.RouteModel","text":"A data class for storing data about a microservice. Parameters: Name Type Description Default request_method Any Is a callable (like app.get, app.post and so on.) required gateway_path str Is the path to bind gateway. required service_url str Is url path to microservice (like \" https://api.example.com/v1 \") required service_path str The path to the endpoint on another service. required query_params Optional [ List [ str ]] Used to extract query parameters from endpoint and transmission to microservice None query_required Optional [ List [ bool ]] Defines whether the specified parameters are mandatory for the request to the microservice. None query_is_cookie Optional [ List [ bool ]] Determines whether the specified parameters should be passed as a cookie. None form_params Optional [ List [ str ]] Used to extract form model parameters from endpoint and transmission to microservice None body_params Optional [ List [ str ]] Used to extract body model from endpoint and transmission to microservice None tags Optional [ List [ str ]] Allows grouped objects in the api docs None dependencies Optional [ str ] See documentation for details - https://fastapi.tiangolo.com/tutorial/dependencies/#declare-the-dependency-in-the-dependant None","title":"RouteModel"},{"location":"CodeReference/domain/usecases/BuildRouteModelsUsecase/","text":"fastapi_gateway_auto_generate . domain . usecases . BuildRouteModelsUsecase . BuildRouteModelsUsecase () \u00b6 The usecase is responsible for creating an instance of the 'RouteModel' model and Pydantic models. Source code in fastapi_gateway_auto_generate/domain/usecases/BuildRouteModelsUsecase.py 25 26 def __init__ ( self ) -> None : self . __open_api_parser : OpenApiParser = OpenApiParser () __generate_models () \u00b6 Pydantic model generator from openapi.json.\" Returns: Name Type Description _uuid str Unique identifier as the file name. classes list [ str ] List of class names. Source code in fastapi_gateway_auto_generate/domain/usecases/BuildRouteModelsUsecase.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def __generate_models ( self ): \"\"\"Pydantic model generator from openapi.json.\" Returns: _uuid (str): Unique identifier as the file name. classes (list[str]): List of class names. \"\"\" shortuuid . set_alphabet ( \"ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\" ) project_root = os . path . dirname ( sys . modules [ 'fastapi_gateway_auto_generate' ] . __file__ ) _uuid = f \"model_ { shortuuid . ShortUUID () . random ( length = 10 ) } \" output = Path ( f ' { project_root } /tmp/models/ { _uuid } .py' ) generate ( input_ = json . dumps ( self . __open_api_parser . get_raw_response_in_json ()), input_file_type = InputFileType . OpenAPI , input_filename = \"example.json\" , output = output ) model : str = output . read_text () classes : list [ str ] = re . findall ( r \"class\\s([A-Za-z0-91]*)\" , model ) return _uuid , classes execute ( config ) \u00b6 Launch execution of usecase Parameters: Name Type Description Default config Config The Config object with its configuration. required Returns: Name Type Description services_result list [ dict [ str , Any ]] Return a list of services, each of which stores a list of RouteModel,Pydantic models, and the service URL. Source code in fastapi_gateway_auto_generate/domain/usecases/BuildRouteModelsUsecase.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def execute ( self , config : Config ) -> list [ dict [ str , Any ]]: \"\"\"Launch execution of usecase Args: config (Config): The Config object with its configuration. Returns: services_result (list[dict[str, Any]]): Return a list of services, each of which stores a list of RouteModel,Pydantic models, and the service URL. \"\"\" services_result : list [ dict [ str , Any ]] = [] get_all_info_services_model : GetAllInfoServices = GetAllInfoServices ( page = 1 ) services , err = GetAllServices ( db_url = config . db_url ) . get_all_services ( get_all_info_services_model = get_all_info_services_model ) if not err is None : logger . warning ( err ) return services_result count_page : int = services [ \"metadata\" ][ \"count_page\" ] StatusService ( db_url = config . db_url ) . delete_all_rows () UrlService ( db_url = config . db_url ) . delete_all_rows () if err is None : for _ in range ( 0 , count_page ): services , err = GetAllServices ( db_url = config . db_url ) . get_all_services ( get_all_info_services_model = get_all_info_services_model ) for service in services [ \"services\" ]: routes_model = [] service_result = {} url = f \" { service [ 'domain' ] } : { service [ 'port' ] } \" logger . debug ( url ) status_code = self . __open_api_parser . parse_from_service ( url = url ) logger . debug ( status_code ) StatusService ( db_url = config . db_url ) . set_status_service ( id_service = service [ \"id\" ], status_code = status_code ) if status_code == - 1 : logger . warning ( f \"Failed to establish connection with the \\\" { service [ 'name' ] } \\\" service.\" ) continue ## TODO: -2 if status_code != 200 : logger . warning ( f \"Code error with the \\\" { service [ 'name' ] } \\\" service.\" ) continue for path in self . __open_api_parser . get_paths (): if self . __open_api_parser . check_api_gateway_tags ( path = path , tag_key = APITags . AUTO_GENERATE ): UrlService ( db_url = config . db_url ) . set_url_service ( id_service = service [ \"id\" ], url = path ) path_method : str = self . __open_api_parser . get_path_method ( path ) dependencies = [] logger . debug ( self . __open_api_parser . get_paths ()) if not ( config . jwt is None ) and self . __open_api_parser . check_api_gateway_tags ( path = path , tag_key = APITags . ENABLE_AUTH ): dependencies . append ( Depends ( config . jwt ( service [ \"name\" ], path , path_method ))) route_model : RouteModel = RouteModel ( request_method = getattr ( config . fast_api_app , path_method ), gateway_path = f \"/ { service [ 'name' ] }{ path } \" , service_url = url , service_path = path , tags = [ service [ \"name\" ]], dependencies = dependencies ) route_model . query_params , route_model . query_required , route_model . query_is_cookie = self . __open_api_parser . get_queries_param ( path = path , method = path_method ) route_model . form_params = self . __open_api_parser . get_body_multipart_form_data ( path = path , method = path_method ) route_model . body_params = self . __open_api_parser . get_body_application_json ( path = path , method = path_method ) routes_model . append ( route_model ) else : continue service_result [ \"models\" ], service_result [ \"model_output\" ] = self . __generate_models ( ) service_result [ \"route_models\" ] = routes_model service_result [ \"service_url\" ] = f \" { service [ 'domain' ] } : { service [ 'port' ] } \" services_result . append ( service_result ) get_all_info_services_model . page += 1 return services_result","title":"BuildRouteModelsUsecase"},{"location":"CodeReference/domain/usecases/BuildRouteModelsUsecase/#fastapi_gateway_auto_generate.domain.usecases.BuildRouteModelsUsecase.BuildRouteModelsUsecase","text":"The usecase is responsible for creating an instance of the 'RouteModel' model and Pydantic models. Source code in fastapi_gateway_auto_generate/domain/usecases/BuildRouteModelsUsecase.py 25 26 def __init__ ( self ) -> None : self . __open_api_parser : OpenApiParser = OpenApiParser ()","title":"BuildRouteModelsUsecase"},{"location":"CodeReference/domain/usecases/BuildRouteModelsUsecase/#fastapi_gateway_auto_generate.domain.usecases.BuildRouteModelsUsecase.BuildRouteModelsUsecase.__generate_models","text":"Pydantic model generator from openapi.json.\" Returns: Name Type Description _uuid str Unique identifier as the file name. classes list [ str ] List of class names. Source code in fastapi_gateway_auto_generate/domain/usecases/BuildRouteModelsUsecase.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def __generate_models ( self ): \"\"\"Pydantic model generator from openapi.json.\" Returns: _uuid (str): Unique identifier as the file name. classes (list[str]): List of class names. \"\"\" shortuuid . set_alphabet ( \"ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\" ) project_root = os . path . dirname ( sys . modules [ 'fastapi_gateway_auto_generate' ] . __file__ ) _uuid = f \"model_ { shortuuid . ShortUUID () . random ( length = 10 ) } \" output = Path ( f ' { project_root } /tmp/models/ { _uuid } .py' ) generate ( input_ = json . dumps ( self . __open_api_parser . get_raw_response_in_json ()), input_file_type = InputFileType . OpenAPI , input_filename = \"example.json\" , output = output ) model : str = output . read_text () classes : list [ str ] = re . findall ( r \"class\\s([A-Za-z0-91]*)\" , model ) return _uuid , classes","title":"__generate_models()"},{"location":"CodeReference/domain/usecases/BuildRouteModelsUsecase/#fastapi_gateway_auto_generate.domain.usecases.BuildRouteModelsUsecase.BuildRouteModelsUsecase.execute","text":"Launch execution of usecase Parameters: Name Type Description Default config Config The Config object with its configuration. required Returns: Name Type Description services_result list [ dict [ str , Any ]] Return a list of services, each of which stores a list of RouteModel,Pydantic models, and the service URL. Source code in fastapi_gateway_auto_generate/domain/usecases/BuildRouteModelsUsecase.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def execute ( self , config : Config ) -> list [ dict [ str , Any ]]: \"\"\"Launch execution of usecase Args: config (Config): The Config object with its configuration. Returns: services_result (list[dict[str, Any]]): Return a list of services, each of which stores a list of RouteModel,Pydantic models, and the service URL. \"\"\" services_result : list [ dict [ str , Any ]] = [] get_all_info_services_model : GetAllInfoServices = GetAllInfoServices ( page = 1 ) services , err = GetAllServices ( db_url = config . db_url ) . get_all_services ( get_all_info_services_model = get_all_info_services_model ) if not err is None : logger . warning ( err ) return services_result count_page : int = services [ \"metadata\" ][ \"count_page\" ] StatusService ( db_url = config . db_url ) . delete_all_rows () UrlService ( db_url = config . db_url ) . delete_all_rows () if err is None : for _ in range ( 0 , count_page ): services , err = GetAllServices ( db_url = config . db_url ) . get_all_services ( get_all_info_services_model = get_all_info_services_model ) for service in services [ \"services\" ]: routes_model = [] service_result = {} url = f \" { service [ 'domain' ] } : { service [ 'port' ] } \" logger . debug ( url ) status_code = self . __open_api_parser . parse_from_service ( url = url ) logger . debug ( status_code ) StatusService ( db_url = config . db_url ) . set_status_service ( id_service = service [ \"id\" ], status_code = status_code ) if status_code == - 1 : logger . warning ( f \"Failed to establish connection with the \\\" { service [ 'name' ] } \\\" service.\" ) continue ## TODO: -2 if status_code != 200 : logger . warning ( f \"Code error with the \\\" { service [ 'name' ] } \\\" service.\" ) continue for path in self . __open_api_parser . get_paths (): if self . __open_api_parser . check_api_gateway_tags ( path = path , tag_key = APITags . AUTO_GENERATE ): UrlService ( db_url = config . db_url ) . set_url_service ( id_service = service [ \"id\" ], url = path ) path_method : str = self . __open_api_parser . get_path_method ( path ) dependencies = [] logger . debug ( self . __open_api_parser . get_paths ()) if not ( config . jwt is None ) and self . __open_api_parser . check_api_gateway_tags ( path = path , tag_key = APITags . ENABLE_AUTH ): dependencies . append ( Depends ( config . jwt ( service [ \"name\" ], path , path_method ))) route_model : RouteModel = RouteModel ( request_method = getattr ( config . fast_api_app , path_method ), gateway_path = f \"/ { service [ 'name' ] }{ path } \" , service_url = url , service_path = path , tags = [ service [ \"name\" ]], dependencies = dependencies ) route_model . query_params , route_model . query_required , route_model . query_is_cookie = self . __open_api_parser . get_queries_param ( path = path , method = path_method ) route_model . form_params = self . __open_api_parser . get_body_multipart_form_data ( path = path , method = path_method ) route_model . body_params = self . __open_api_parser . get_body_application_json ( path = path , method = path_method ) routes_model . append ( route_model ) else : continue service_result [ \"models\" ], service_result [ \"model_output\" ] = self . __generate_models ( ) service_result [ \"route_models\" ] = routes_model service_result [ \"service_url\" ] = f \" { service [ 'domain' ] } : { service [ 'port' ] } \" services_result . append ( service_result ) get_all_info_services_model . page += 1 return services_result","title":"execute()"},{"location":"CodeReference/domain/usecases/BuildRoutesUsecase/","text":"fastapi_gateway_auto_generate . domain . usecases . BuildRoutesUsecase . BuildRoutesUsecase () \u00b6 The usecase responsible for adding services to the FastAPI object. Source code in fastapi_gateway_auto_generate/domain/usecases/BuildRoutesUsecase.py 22 23 24 def __init__ ( self ) -> None : self . models_routes_vars = {} self . models_routes = {} __factory_func ( route_model , _import ) \u00b6 Dynamic generation of functions for adding to the FastAPI object. Parameters: Name Type Description Default services_result list[dict[str, Any] The Config object with its configuration. required Source code in fastapi_gateway_auto_generate/domain/usecases/BuildRoutesUsecase.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def __factory_func ( self , route_model : RouteModel , _import : str ) -> FunctionType : \"\"\"Dynamic generation of functions for adding to the FastAPI object. Args: services_result (list[dict[str, Any]): The Config object with its configuration. \"\"\" def func_impl ( * args , ** kwargs ): pass func_impl () arguments : list [ dict [ str , str ]] = [] queries = \"\" files = \"\" body_list = [] # Body if not route_model . body_params is None : for i , body in enumerate ( route_model . body_params ): argument = {} argument [ \"name\" ] = body + f \" { i } \" argument [ \"type\" ] = f \" { _import } . { body } \" # if not route_model.query_required[i]: # argument[\"value\"] = \"None\" # argument[\"type\"] = \"str | None\" # if route_model.query_is_cookie[i]: # argument[\"value\"] = \"fastapi.Cookie(default=None)\" body_list . append ( body + f \" { i } \" ) arguments . append ( argument ) # Queries if not route_model . query_params is None : for i , query in enumerate ( route_model . query_params ): argument = {} argument [ \"name\" ] = query argument [ \"type\" ] = \"str\" if not route_model . query_required [ i ]: argument [ \"value\" ] = \"None\" argument [ \"type\" ] = \"str | None\" if route_model . query_is_cookie [ i ]: argument [ \"value\" ] = \"fastapi.Cookie(default=None)\" arguments . append ( argument ) # Files if not route_model . form_params is None : for file in route_model . form_params : argument = {} argument [ \"name\" ] = file argument [ \"type\" ] = \"fastapi.UploadFile\" argument [ \"value\" ] = \"fastapi.File()\" arguments . append ( argument ) func_sig : str = \"func(request: fastapi.Request, response: fastapi.Response, \" for argument in arguments : func_sig += f \" { argument [ 'name' ] } : { argument [ 'type' ] } \" if not argument . get ( \"value\" ) is None : func_sig += f \" = { argument [ 'value' ] } , \" else : func_sig += \", \" func_sig += \")\" # Cookie logger . debug ( func_sig ) test = create_function ( func_sig , func_impl ) # exit() return test , body_list __import_model ( service_model_name ) \u00b6 Dynamic import of Pydantic models. Parameters: Name Type Description Default service_model_name list[dict[str, Any] The Config object with its configuration. required Source code in fastapi_gateway_auto_generate/domain/usecases/BuildRoutesUsecase.py 63 64 65 66 67 68 69 70 71 def __import_model ( self , service_model_name : str ) -> str : \"\"\"Dynamic import of Pydantic models. Args: service_model_name (list[dict[str, Any]): The Config object with its configuration. \"\"\" _import : str = f \"fastapi_gateway_auto_generate.tmp.models. { service_model_name } \" importlib . import_module ( _import ) return _import execute ( services_result , fast_api_app ) \u00b6 Launch execution of usecase Parameters: Name Type Description Default services_result list[dict[str, Any] The Config object with its configuration. required Source code in fastapi_gateway_auto_generate/domain/usecases/BuildRoutesUsecase.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def execute ( self , services_result : list [ dict [ str , Any ]], fast_api_app : FastAPI ) -> None : \"\"\"Launch execution of usecase Args: services_result (list[dict[str, Any]): The Config object with its configuration. \"\"\" for service_result in services_result : for route_model in service_result [ \"route_models\" ]: # print( # exec(f\"tmp.models.{service_result['models']}.ConversionParams()\")) # exit() # logger.debug(route_model) _import : str = self . __import_model ( service_model_name = service_result [ 'models' ]) func , body_list = self . __factory_func ( route_model = route_model , _import = _import ) route ( request_method = route_model . request_method , gateway_path = route_model . gateway_path , service_url = route_model . service_url , service_path = route_model . service_path , query_params = route_model . query_params , form_params = route_model . form_params , tags = route_model . tags , body_params = body_list , dependencies = route_model . dependencies , )( f = func ) UpdateOpenApiSchemaUsecase () . execute ( fast_api_app = fast_api_app ) DeleteTmpModelsFilesUsecase () . execute ()","title":"BuildRoutesUsecase"},{"location":"CodeReference/domain/usecases/BuildRoutesUsecase/#fastapi_gateway_auto_generate.domain.usecases.BuildRoutesUsecase.BuildRoutesUsecase","text":"The usecase responsible for adding services to the FastAPI object. Source code in fastapi_gateway_auto_generate/domain/usecases/BuildRoutesUsecase.py 22 23 24 def __init__ ( self ) -> None : self . models_routes_vars = {} self . models_routes = {}","title":"BuildRoutesUsecase"},{"location":"CodeReference/domain/usecases/BuildRoutesUsecase/#fastapi_gateway_auto_generate.domain.usecases.BuildRoutesUsecase.BuildRoutesUsecase.__factory_func","text":"Dynamic generation of functions for adding to the FastAPI object. Parameters: Name Type Description Default services_result list[dict[str, Any] The Config object with its configuration. required Source code in fastapi_gateway_auto_generate/domain/usecases/BuildRoutesUsecase.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def __factory_func ( self , route_model : RouteModel , _import : str ) -> FunctionType : \"\"\"Dynamic generation of functions for adding to the FastAPI object. Args: services_result (list[dict[str, Any]): The Config object with its configuration. \"\"\" def func_impl ( * args , ** kwargs ): pass func_impl () arguments : list [ dict [ str , str ]] = [] queries = \"\" files = \"\" body_list = [] # Body if not route_model . body_params is None : for i , body in enumerate ( route_model . body_params ): argument = {} argument [ \"name\" ] = body + f \" { i } \" argument [ \"type\" ] = f \" { _import } . { body } \" # if not route_model.query_required[i]: # argument[\"value\"] = \"None\" # argument[\"type\"] = \"str | None\" # if route_model.query_is_cookie[i]: # argument[\"value\"] = \"fastapi.Cookie(default=None)\" body_list . append ( body + f \" { i } \" ) arguments . append ( argument ) # Queries if not route_model . query_params is None : for i , query in enumerate ( route_model . query_params ): argument = {} argument [ \"name\" ] = query argument [ \"type\" ] = \"str\" if not route_model . query_required [ i ]: argument [ \"value\" ] = \"None\" argument [ \"type\" ] = \"str | None\" if route_model . query_is_cookie [ i ]: argument [ \"value\" ] = \"fastapi.Cookie(default=None)\" arguments . append ( argument ) # Files if not route_model . form_params is None : for file in route_model . form_params : argument = {} argument [ \"name\" ] = file argument [ \"type\" ] = \"fastapi.UploadFile\" argument [ \"value\" ] = \"fastapi.File()\" arguments . append ( argument ) func_sig : str = \"func(request: fastapi.Request, response: fastapi.Response, \" for argument in arguments : func_sig += f \" { argument [ 'name' ] } : { argument [ 'type' ] } \" if not argument . get ( \"value\" ) is None : func_sig += f \" = { argument [ 'value' ] } , \" else : func_sig += \", \" func_sig += \")\" # Cookie logger . debug ( func_sig ) test = create_function ( func_sig , func_impl ) # exit() return test , body_list","title":"__factory_func()"},{"location":"CodeReference/domain/usecases/BuildRoutesUsecase/#fastapi_gateway_auto_generate.domain.usecases.BuildRoutesUsecase.BuildRoutesUsecase.__import_model","text":"Dynamic import of Pydantic models. Parameters: Name Type Description Default service_model_name list[dict[str, Any] The Config object with its configuration. required Source code in fastapi_gateway_auto_generate/domain/usecases/BuildRoutesUsecase.py 63 64 65 66 67 68 69 70 71 def __import_model ( self , service_model_name : str ) -> str : \"\"\"Dynamic import of Pydantic models. Args: service_model_name (list[dict[str, Any]): The Config object with its configuration. \"\"\" _import : str = f \"fastapi_gateway_auto_generate.tmp.models. { service_model_name } \" importlib . import_module ( _import ) return _import","title":"__import_model()"},{"location":"CodeReference/domain/usecases/BuildRoutesUsecase/#fastapi_gateway_auto_generate.domain.usecases.BuildRoutesUsecase.BuildRoutesUsecase.execute","text":"Launch execution of usecase Parameters: Name Type Description Default services_result list[dict[str, Any] The Config object with its configuration. required Source code in fastapi_gateway_auto_generate/domain/usecases/BuildRoutesUsecase.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def execute ( self , services_result : list [ dict [ str , Any ]], fast_api_app : FastAPI ) -> None : \"\"\"Launch execution of usecase Args: services_result (list[dict[str, Any]): The Config object with its configuration. \"\"\" for service_result in services_result : for route_model in service_result [ \"route_models\" ]: # print( # exec(f\"tmp.models.{service_result['models']}.ConversionParams()\")) # exit() # logger.debug(route_model) _import : str = self . __import_model ( service_model_name = service_result [ 'models' ]) func , body_list = self . __factory_func ( route_model = route_model , _import = _import ) route ( request_method = route_model . request_method , gateway_path = route_model . gateway_path , service_url = route_model . service_url , service_path = route_model . service_path , query_params = route_model . query_params , form_params = route_model . form_params , tags = route_model . tags , body_params = body_list , dependencies = route_model . dependencies , )( f = func ) UpdateOpenApiSchemaUsecase () . execute ( fast_api_app = fast_api_app ) DeleteTmpModelsFilesUsecase () . execute ()","title":"execute()"},{"location":"CodeReference/domain/usecases/DeleteTmpModelsFilesUsecase/","text":"fastapi_gateway_auto_generate . domain . usecases . DeleteTmpModelsFilesUsecase . DeleteTmpModelsFilesUsecase () \u00b6 The usecase designed for deleting temporary pydantic models. Source code in fastapi_gateway_auto_generate/domain/usecases/DeleteTmpModelsFilesUsecase.py 11 12 def __init__ ( self ) -> None : pass execute () \u00b6 Launch execution of usecase Source code in fastapi_gateway_auto_generate/domain/usecases/DeleteTmpModelsFilesUsecase.py 14 15 16 17 18 19 20 21 22 23 24 def execute ( self ): \"\"\"Launch execution of usecase \"\"\" project_root = os . path . dirname ( sys . modules [ 'fastapi_gateway_auto_generate' ] . __file__ ) filelist = glob . glob ( os . path . join ( f \" { project_root } /tmp/models\" , \"model_*\" )) for f in filelist : logger . debug ( f \"The file \\\" { os . path . basename ( f ) } \\\" has been deleted.\" ) os . remove ( f )","title":"DeleteTmpModelsFilesUsecase"},{"location":"CodeReference/domain/usecases/DeleteTmpModelsFilesUsecase/#fastapi_gateway_auto_generate.domain.usecases.DeleteTmpModelsFilesUsecase.DeleteTmpModelsFilesUsecase","text":"The usecase designed for deleting temporary pydantic models. Source code in fastapi_gateway_auto_generate/domain/usecases/DeleteTmpModelsFilesUsecase.py 11 12 def __init__ ( self ) -> None : pass","title":"DeleteTmpModelsFilesUsecase"},{"location":"CodeReference/domain/usecases/DeleteTmpModelsFilesUsecase/#fastapi_gateway_auto_generate.domain.usecases.DeleteTmpModelsFilesUsecase.DeleteTmpModelsFilesUsecase.execute","text":"Launch execution of usecase Source code in fastapi_gateway_auto_generate/domain/usecases/DeleteTmpModelsFilesUsecase.py 14 15 16 17 18 19 20 21 22 23 24 def execute ( self ): \"\"\"Launch execution of usecase \"\"\" project_root = os . path . dirname ( sys . modules [ 'fastapi_gateway_auto_generate' ] . __file__ ) filelist = glob . glob ( os . path . join ( f \" { project_root } /tmp/models\" , \"model_*\" )) for f in filelist : logger . debug ( f \"The file \\\" { os . path . basename ( f ) } \\\" has been deleted.\" ) os . remove ( f )","title":"execute()"},{"location":"CodeReference/domain/usecases/InitDatabaseUsecase/","text":"fastapi_gateway_auto_generate . domain . usecases . InitDatabaseUsecase . InitDatabaseUsecase () \u00b6 The usecase for initializing and verifying database migrations. Source code in fastapi_gateway_auto_generate/domain/usecases/InitDatabaseUsecase.py 12 13 def __init__ ( self ) -> None : pass execute ( db_path , db_url ) \u00b6 Launch execution of usecase Parameters: Name Type Description Default db_url str The path to the SQLite database. required Source code in fastapi_gateway_auto_generate/domain/usecases/InitDatabaseUsecase.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def execute ( self , db_path : str , db_url : str ) -> None : \"\"\"Launch execution of usecase Args: db_url (str): The path to the SQLite database. \"\"\" if not os . path . exists ( db_path ): os . makedirs ( db_path ) project_root = os . path . dirname ( sys . modules [ 'fastapi_gateway_auto_generate' ] . __file__ ) logger . debug ( project_root ) alembic_cfg = alembic_config ( f \" { project_root } /alembic.ini\" ) alembic_cfg . set_main_option ( \"sqlalchemy.url\" , db_url ) logger . debug ( db_url ) command . upgrade ( alembic_cfg , \"head\" )","title":"InitDatabaseUsecase"},{"location":"CodeReference/domain/usecases/InitDatabaseUsecase/#fastapi_gateway_auto_generate.domain.usecases.InitDatabaseUsecase.InitDatabaseUsecase","text":"The usecase for initializing and verifying database migrations. Source code in fastapi_gateway_auto_generate/domain/usecases/InitDatabaseUsecase.py 12 13 def __init__ ( self ) -> None : pass","title":"InitDatabaseUsecase"},{"location":"CodeReference/domain/usecases/InitDatabaseUsecase/#fastapi_gateway_auto_generate.domain.usecases.InitDatabaseUsecase.InitDatabaseUsecase.execute","text":"Launch execution of usecase Parameters: Name Type Description Default db_url str The path to the SQLite database. required Source code in fastapi_gateway_auto_generate/domain/usecases/InitDatabaseUsecase.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def execute ( self , db_path : str , db_url : str ) -> None : \"\"\"Launch execution of usecase Args: db_url (str): The path to the SQLite database. \"\"\" if not os . path . exists ( db_path ): os . makedirs ( db_path ) project_root = os . path . dirname ( sys . modules [ 'fastapi_gateway_auto_generate' ] . __file__ ) logger . debug ( project_root ) alembic_cfg = alembic_config ( f \" { project_root } /alembic.ini\" ) alembic_cfg . set_main_option ( \"sqlalchemy.url\" , db_url ) logger . debug ( db_url ) command . upgrade ( alembic_cfg , \"head\" )","title":"execute()"},{"location":"CodeReference/domain/usecases/RefreshServicesUsecase/","text":"fastapi_gateway_auto_generate . domain . usecases . RefreshServicesUsecase . RefreshServicesUsecase () \u00b6 The usecase for updating and verifying all connected services. Source code in fastapi_gateway_auto_generate/domain/usecases/RefreshServicesUsecase.py 14 15 def __init__ ( self ): pass execute ( config ) \u00b6 Launch execution of usecase Parameters: Name Type Description Default config Config The Config object with its configuration. required Source code in fastapi_gateway_auto_generate/domain/usecases/RefreshServicesUsecase.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def execute ( self , config : Config ) -> None : \"\"\"Launch execution of usecase Args: config (Config): The Config object with its configuration. \"\"\" get_all_info_services_model : GetAllInfoServices = GetAllInfoServices ( page = 1 ) services , err = GetAllServices ( db_url = config . db_url ) . get_all_services ( get_all_info_services_model = get_all_info_services_model ) if not err is None : return None count_page : int = services [ \"metadata\" ][ \"count_page\" ] routes = config . fast_api_app . router . routes for _ in range ( 0 , count_page ): for service in services [ \"services\" ]: for url in service [ \"urls\" ]: for i , r in enumerate ( routes ): if r . path == f \"/ { service [ 'name' ] }{ url } \" : del config . fast_api_app . routes [ i ] logger . debug ( r ) if service [ 'delete' ]: # print(service['id']) DeleteService ( db_url = config . db_url ) . delete_service ( delete_service_model = delete_service_model ( id_service = service [ 'id' ]) ) services_result = BuildRouteModelsUsecase () . execute ( config = config ) BuildRoutesUsecase () . execute ( services_result = services_result , fast_api_app = config . fast_api_app ) logger . success ( \"Services have been successfully updated\" )","title":"RefreshServicesUsecase"},{"location":"CodeReference/domain/usecases/RefreshServicesUsecase/#fastapi_gateway_auto_generate.domain.usecases.RefreshServicesUsecase.RefreshServicesUsecase","text":"The usecase for updating and verifying all connected services. Source code in fastapi_gateway_auto_generate/domain/usecases/RefreshServicesUsecase.py 14 15 def __init__ ( self ): pass","title":"RefreshServicesUsecase"},{"location":"CodeReference/domain/usecases/RefreshServicesUsecase/#fastapi_gateway_auto_generate.domain.usecases.RefreshServicesUsecase.RefreshServicesUsecase.execute","text":"Launch execution of usecase Parameters: Name Type Description Default config Config The Config object with its configuration. required Source code in fastapi_gateway_auto_generate/domain/usecases/RefreshServicesUsecase.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def execute ( self , config : Config ) -> None : \"\"\"Launch execution of usecase Args: config (Config): The Config object with its configuration. \"\"\" get_all_info_services_model : GetAllInfoServices = GetAllInfoServices ( page = 1 ) services , err = GetAllServices ( db_url = config . db_url ) . get_all_services ( get_all_info_services_model = get_all_info_services_model ) if not err is None : return None count_page : int = services [ \"metadata\" ][ \"count_page\" ] routes = config . fast_api_app . router . routes for _ in range ( 0 , count_page ): for service in services [ \"services\" ]: for url in service [ \"urls\" ]: for i , r in enumerate ( routes ): if r . path == f \"/ { service [ 'name' ] }{ url } \" : del config . fast_api_app . routes [ i ] logger . debug ( r ) if service [ 'delete' ]: # print(service['id']) DeleteService ( db_url = config . db_url ) . delete_service ( delete_service_model = delete_service_model ( id_service = service [ 'id' ]) ) services_result = BuildRouteModelsUsecase () . execute ( config = config ) BuildRoutesUsecase () . execute ( services_result = services_result , fast_api_app = config . fast_api_app ) logger . success ( \"Services have been successfully updated\" )","title":"execute()"},{"location":"CodeReference/domain/usecases/UpdateOpenApiSchemaUsecase/","text":"fastapi_gateway_auto_generate . domain . usecases . UpdateOpenApiSchemaUsecase . UpdateOpenApiSchemaUsecase () \u00b6 The usecase for updating the OpenAPI schema. Source code in fastapi_gateway_auto_generate/domain/usecases/UpdateOpenApiSchemaUsecase.py 8 9 def __init__ ( self ) -> None : pass execute ( fast_api_app ) \u00b6 Launch execution of usecase Parameters: Name Type Description Default fast_api_app FastAPI Pointer to your FastAPI application. required Source code in fastapi_gateway_auto_generate/domain/usecases/UpdateOpenApiSchemaUsecase.py 11 12 13 14 15 16 17 18 19 20 def execute ( self , fast_api_app : FastAPI ) -> bool : \"\"\"Launch execution of usecase Args: fast_api_app (FastAPI): Pointer to your FastAPI application. \"\"\" fast_api_app . openapi_schema = None fast_api_app . openapi () return True","title":"UpdateOpenApiSchemaUsecase"},{"location":"CodeReference/domain/usecases/UpdateOpenApiSchemaUsecase/#fastapi_gateway_auto_generate.domain.usecases.UpdateOpenApiSchemaUsecase.UpdateOpenApiSchemaUsecase","text":"The usecase for updating the OpenAPI schema. Source code in fastapi_gateway_auto_generate/domain/usecases/UpdateOpenApiSchemaUsecase.py 8 9 def __init__ ( self ) -> None : pass","title":"UpdateOpenApiSchemaUsecase"},{"location":"CodeReference/domain/usecases/UpdateOpenApiSchemaUsecase/#fastapi_gateway_auto_generate.domain.usecases.UpdateOpenApiSchemaUsecase.UpdateOpenApiSchemaUsecase.execute","text":"Launch execution of usecase Parameters: Name Type Description Default fast_api_app FastAPI Pointer to your FastAPI application. required Source code in fastapi_gateway_auto_generate/domain/usecases/UpdateOpenApiSchemaUsecase.py 11 12 13 14 15 16 17 18 19 20 def execute ( self , fast_api_app : FastAPI ) -> bool : \"\"\"Launch execution of usecase Args: fast_api_app (FastAPI): Pointer to your FastAPI application. \"\"\" fast_api_app . openapi_schema = None fast_api_app . openapi () return True","title":"execute()"},{"location":"CodeReference/exceptions/ConfigException/","text":"","title":"ConfigException"},{"location":"CodeReference/exceptions/FastapiGatewayAutoGenerageException/","text":"","title":"FastapiGatewayAutoGenerageException"},{"location":"CodeReference/management/Management/","text":"fastapi_gateway_auto_generate.management.Management \u00b6","title":"Management"},{"location":"CodeReference/management/Management/#fastapi_gateway_auto_generate.management.Management","text":"","title":"Management"},{"location":"CodeReference/management/models/AddService/","text":"","title":"AddService"},{"location":"CodeReference/management/models/DeleteService/","text":"","title":"DeleteService"},{"location":"CodeReference/management/models/GetAllInfoServices/","text":"","title":"GetAllInfoServices"},{"location":"CodeReference/management/routes/AddServiceRoute/","text":"fastapi_gateway_auto_generate.management.routes.AddServiceRoute \u00b6 AddServiceRoute ( config ) \u00b6 Router for adding a service Parameters: Name Type Description Default config Config The Config object with its configuration. required Returns: Name Type Description result bool True if the addition was successful, otherwise False. Source code in fastapi_gateway_auto_generate/management/routes/AddServiceRoute.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , config : Config ) -> None : self . __config : Config = config self . route : APIRouter = APIRouter () self . __dependencies = [] if not self . __config . jwt is None : self . __dependencies . append ( Depends ( self . __config . jwt ( self . __config . service_name , \"/service\" , \"post\" ))) @self . route . post ( \"/service\" , tags = [ \"Service management\" ], dependencies = self . __dependencies ) async def add_service ( add_service : AddService ) -> dict [ str , dict [ str , str | int ]]: result , err = add_service_database ( db_url = self . __config . db_url ) . add_service ( add_service_model = add_service ) if err : raise HTTPException ( status_code = 409 , detail = err ) return success_code ( msg = \"The service has been added\" )","title":"AddServiceRoute"},{"location":"CodeReference/management/routes/AddServiceRoute/#fastapi_gateway_auto_generate.management.routes.AddServiceRoute","text":"","title":"AddServiceRoute"},{"location":"CodeReference/management/routes/AddServiceRoute/#fastapi_gateway_auto_generate.management.routes.AddServiceRoute.AddServiceRoute","text":"Router for adding a service Parameters: Name Type Description Default config Config The Config object with its configuration. required Returns: Name Type Description result bool True if the addition was successful, otherwise False. Source code in fastapi_gateway_auto_generate/management/routes/AddServiceRoute.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , config : Config ) -> None : self . __config : Config = config self . route : APIRouter = APIRouter () self . __dependencies = [] if not self . __config . jwt is None : self . __dependencies . append ( Depends ( self . __config . jwt ( self . __config . service_name , \"/service\" , \"post\" ))) @self . route . post ( \"/service\" , tags = [ \"Service management\" ], dependencies = self . __dependencies ) async def add_service ( add_service : AddService ) -> dict [ str , dict [ str , str | int ]]: result , err = add_service_database ( db_url = self . __config . db_url ) . add_service ( add_service_model = add_service ) if err : raise HTTPException ( status_code = 409 , detail = err ) return success_code ( msg = \"The service has been added\" )","title":"AddServiceRoute"},{"location":"CodeReference/management/routes/DeleteServiceRoute/","text":"fastapi_gateway_auto_generate.management.routes.DeleteServiceRoute \u00b6 DeleteServiceRoute ( config ) \u00b6 Router for deleting a service Parameters: Name Type Description Default config Config The Config object with its configuration. required Returns: Name Type Description result bool True if the service was successfully marked as deleted, False in case of an error. Source code in fastapi_gateway_auto_generate/management/routes/DeleteServiceRoute.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def __init__ ( self , config : Config ) -> None : self . __config : Config = config self . route : APIRouter = APIRouter () self . __dependencies = [] if not self . __config . jwt is None : self . __dependencies . append ( Depends ( self . __config . jwt ( self . __config . service_name , \"/service\" , \"delete\" ))) @self . route . delete ( \"/service\" , tags = [ \"Service management\" ], dependencies = self . __dependencies ) async def delete_service ( delete_service : DeleteService = Depends ()) -> dict [ str , dict [ str , str | int ]]: result , err = set_mark_delete_service_database ( db_url = self . __config . db_url ) . set_mark_delete_service ( delete_service_model = delete_service ) if err : raise HTTPException ( status_code = 409 , detail = err ) return success_code ( msg = \"The service has been successfully marked as deleted\" )","title":"DeleteServiceRoute"},{"location":"CodeReference/management/routes/DeleteServiceRoute/#fastapi_gateway_auto_generate.management.routes.DeleteServiceRoute","text":"","title":"DeleteServiceRoute"},{"location":"CodeReference/management/routes/DeleteServiceRoute/#fastapi_gateway_auto_generate.management.routes.DeleteServiceRoute.DeleteServiceRoute","text":"Router for deleting a service Parameters: Name Type Description Default config Config The Config object with its configuration. required Returns: Name Type Description result bool True if the service was successfully marked as deleted, False in case of an error. Source code in fastapi_gateway_auto_generate/management/routes/DeleteServiceRoute.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def __init__ ( self , config : Config ) -> None : self . __config : Config = config self . route : APIRouter = APIRouter () self . __dependencies = [] if not self . __config . jwt is None : self . __dependencies . append ( Depends ( self . __config . jwt ( self . __config . service_name , \"/service\" , \"delete\" ))) @self . route . delete ( \"/service\" , tags = [ \"Service management\" ], dependencies = self . __dependencies ) async def delete_service ( delete_service : DeleteService = Depends ()) -> dict [ str , dict [ str , str | int ]]: result , err = set_mark_delete_service_database ( db_url = self . __config . db_url ) . set_mark_delete_service ( delete_service_model = delete_service ) if err : raise HTTPException ( status_code = 409 , detail = err ) return success_code ( msg = \"The service has been successfully marked as deleted\" )","title":"DeleteServiceRoute"},{"location":"CodeReference/management/routes/GetAllInfoServicesRoute/","text":"fastapi_gateway_auto_generate.management.routes.GetAllInfoServicesRoute \u00b6","title":"GetAllInfoServicesRoute"},{"location":"CodeReference/management/routes/GetAllInfoServicesRoute/#fastapi_gateway_auto_generate.management.routes.GetAllInfoServicesRoute","text":"","title":"GetAllInfoServicesRoute"},{"location":"CodeReference/management/routes/RefreshServicesRoute/","text":"fastapi_gateway_auto_generate.management.routes.RefreshServicesRoute \u00b6","title":"RefreshServicesRoute"},{"location":"CodeReference/management/routes/RefreshServicesRoute/#fastapi_gateway_auto_generate.management.routes.RefreshServicesRoute","text":"","title":"RefreshServicesRoute"},{"location":"Usage/getting-started/","text":"Getting started \u00b6 1. Additional metadata for tags \u00b6 In order for the url from the microservice to be transferred to the API Gateway, you need to add additional metadata for your tags. In our case, this is x-auto-generate-in-api-gateway . For example, we have such a microservice. Example The example was taken on the website FastAPI (Create metadata for tags) app.py from fastapi import FastAPI import uvicorn tags_metadata = [ { \"name\" : \"users\" , \"description\" : \"Operations with users. The **login** logic is also here.\" , }, { \"name\" : \"items\" , \"description\" : \"Manage items. So _fancy_ they have their own docs.\" , \"externalDocs\" : { \"description\" : \"Items external docs\" , \"url\" : \"https://fastapi.tiangolo.com/\" , }, }, ] app = FastAPI ( openapi_tags = tags_metadata ) @app . get ( \"/users/\" , tags = [ \"users\" ]) async def get_users (): return [{ \"name\" : \"Harry\" }, { \"name\" : \"Ron\" }] @app . get ( \"/items/\" , tags = [ \"items\" ]) async def get_items (): return [{ \"name\" : \"wand\" }, { \"name\" : \"flying broom\" }] if __name__ == '__main__' : uvicorn . run ( app , port = 5000 , log_level = \"info\" ) Adds an additional tag x-auto-generate-in-api-gateway in order for it to be transferred to the API Gateway. app.py from fastapi import FastAPI import uvicorn tags_metadata = [ { \"name\" : \"users\" , \"description\" : \"Operations with users. The **login** logic is also here.\" , \"x-auto-generate-in-api-gateway\" : True , # (1)! }, { \"name\" : \"items\" , \"description\" : \"Manage items. So _fancy_ they have their own docs.\" , \"externalDocs\" : { \"description\" : \"Items external docs\" , \"url\" : \"https://fastapi.tiangolo.com/\" }, \"x-auto-generate-in-api-gateway\" : True , # (2)! }, ] app = FastAPI ( openapi_tags = tags_metadata ) @app . get ( \"/users/\" , tags = [ \"users\" ]) async def get_users (): return [{ \"name\" : \"Harry\" }, { \"name\" : \"Ron\" }] @app . get ( \"/items/\" , tags = [ \"items\" ]) async def get_items (): return [{ \"name\" : \"wand\" }, { \"name\" : \"flying broom\" }] if __name__ == '__main__' : uvicorn . run ( app , port = 5000 , log_level = \"info\" ) Tag for transferred to the API Gateway. Tag for transferred to the API Gateway. Now who has the tag users and items will be automatically transferred to the API Gateway. 2. Initializing an object in the API Gateway \u00b6 Create Config object \u00b6 When creating an object, first we need to configure our generator. There is a \"Config\" class for this. from fastapi_gateway_auto_generate import Config from fastapi import FastAPI app = FastAPI () config = Config ( fast_api_app = app , ) Info You can find more information about the Config class in the Code Reference. Example creating a simple generator \u00b6 app.py from fastapi_gateway_auto_generate import Generator , Config from fastapi import FastAPI import uvicorn app = FastAPI () config = Config ( fast_api_app = app , ) Generator ( config = config ) if __name__ == \"__main__\" : uvicorn . run ( app = app , port = 5000 , log_level = \"info\" ) After all the manipulations, you will have urls in Swagger for managing services. You can read more details about Service management here .","title":"Getting started"},{"location":"Usage/getting-started/#getting-started","text":"","title":"Getting started"},{"location":"Usage/getting-started/#1-additional-metadata-for-tags","text":"In order for the url from the microservice to be transferred to the API Gateway, you need to add additional metadata for your tags. In our case, this is x-auto-generate-in-api-gateway . For example, we have such a microservice. Example The example was taken on the website FastAPI (Create metadata for tags) app.py from fastapi import FastAPI import uvicorn tags_metadata = [ { \"name\" : \"users\" , \"description\" : \"Operations with users. The **login** logic is also here.\" , }, { \"name\" : \"items\" , \"description\" : \"Manage items. So _fancy_ they have their own docs.\" , \"externalDocs\" : { \"description\" : \"Items external docs\" , \"url\" : \"https://fastapi.tiangolo.com/\" , }, }, ] app = FastAPI ( openapi_tags = tags_metadata ) @app . get ( \"/users/\" , tags = [ \"users\" ]) async def get_users (): return [{ \"name\" : \"Harry\" }, { \"name\" : \"Ron\" }] @app . get ( \"/items/\" , tags = [ \"items\" ]) async def get_items (): return [{ \"name\" : \"wand\" }, { \"name\" : \"flying broom\" }] if __name__ == '__main__' : uvicorn . run ( app , port = 5000 , log_level = \"info\" ) Adds an additional tag x-auto-generate-in-api-gateway in order for it to be transferred to the API Gateway. app.py from fastapi import FastAPI import uvicorn tags_metadata = [ { \"name\" : \"users\" , \"description\" : \"Operations with users. The **login** logic is also here.\" , \"x-auto-generate-in-api-gateway\" : True , # (1)! }, { \"name\" : \"items\" , \"description\" : \"Manage items. So _fancy_ they have their own docs.\" , \"externalDocs\" : { \"description\" : \"Items external docs\" , \"url\" : \"https://fastapi.tiangolo.com/\" }, \"x-auto-generate-in-api-gateway\" : True , # (2)! }, ] app = FastAPI ( openapi_tags = tags_metadata ) @app . get ( \"/users/\" , tags = [ \"users\" ]) async def get_users (): return [{ \"name\" : \"Harry\" }, { \"name\" : \"Ron\" }] @app . get ( \"/items/\" , tags = [ \"items\" ]) async def get_items (): return [{ \"name\" : \"wand\" }, { \"name\" : \"flying broom\" }] if __name__ == '__main__' : uvicorn . run ( app , port = 5000 , log_level = \"info\" ) Tag for transferred to the API Gateway. Tag for transferred to the API Gateway. Now who has the tag users and items will be automatically transferred to the API Gateway.","title":"1. Additional metadata for tags"},{"location":"Usage/getting-started/#2-initializing-an-object-in-the-api-gateway","text":"","title":"2. Initializing an object in the API Gateway"},{"location":"Usage/getting-started/#create-config-object","text":"When creating an object, first we need to configure our generator. There is a \"Config\" class for this. from fastapi_gateway_auto_generate import Config from fastapi import FastAPI app = FastAPI () config = Config ( fast_api_app = app , ) Info You can find more information about the Config class in the Code Reference.","title":"Create Config object"},{"location":"Usage/getting-started/#example-creating-a-simple-generator","text":"app.py from fastapi_gateway_auto_generate import Generator , Config from fastapi import FastAPI import uvicorn app = FastAPI () config = Config ( fast_api_app = app , ) Generator ( config = config ) if __name__ == \"__main__\" : uvicorn . run ( app = app , port = 5000 , log_level = \"info\" ) After all the manipulations, you will have urls in Swagger for managing services. You can read more details about Service management here .","title":"Example creating a simple generator"},{"location":"Usage/security/","text":"Security \u00b6 Info This functionality has not yet been implemented","title":"Security"},{"location":"Usage/security/#security","text":"Info This functionality has not yet been implemented","title":"Security"},{"location":"Usage/service-management/","text":"Service management \u00b6 The library has built-in urls for managing services. Service management is enabled by default. If desired, you can disable the built-in service management system if you do not need it. There is a service_management parameter for this. URLs \u00b6 Add service \u00b6 Method Path POST /service Description \u00b6 Adds a service to the database. Body \u00b6 { \"domain\" : \"string\" , \"name_service\" : \"string\" , \"port\" : 80 } domain - The domain of your service. It is mandatory to specify the protocol. For example, http://127.0.0.1 name_service - The name of the service. It must be unique. After specifying the name, the URL will look like this: https://127.0.0.1:80/{name_service}/... port - The port of the service. Failure You cannot specify the port in the domain. For example: http://127.0.0.1:8080 You need to specify them separately. Response \u00b6 True if the addition was successful, otherwise False. Example ( Python requests ) \u00b6 # Install the Python Requests library: # `pip install requests` import requests def send_request (): # Request # POST http://127.0.0.1:5000/service try : response = requests . post ( url = \"http://127.0.0.1:5000/service\" , params = { \"ip\" : \"127.0.0.1\" , \"port\" : \"8080\" , \"name_service\" : \"Hello\" , }, ) print ( 'Response HTTP Status Code: {status_code} ' . format ( status_code = response . status_code )) print ( 'Response HTTP Response Body: {content} ' . format ( content = response . content )) except requests . exceptions . RequestException : print ( 'HTTP Request failed' ) Delete service \u00b6 Refresh services \u00b6 Method Path PATCH /services Description \u00b6 Updates the URL and checks the functionality of the services without first restarting the program. Example ( Python requests ) \u00b6 # Install the Python Requests library: # `pip install requests` import requests def send_request (): # Request # PATCH http://127.0.0.1:5000/services try : response = requests . patch ( url = \"http://127.0.0.1:5000/services\" , ) print ( 'Response HTTP Status Code: {status_code} ' . format ( status_code = response . status_code )) print ( 'Response HTTP Response Body: {content} ' . format ( content = response . content )) except requests . exceptions . RequestException : print ( 'HTTP Request failed' ) Get info all services \u00b6","title":"API"},{"location":"Usage/service-management/#service-management","text":"The library has built-in urls for managing services. Service management is enabled by default. If desired, you can disable the built-in service management system if you do not need it. There is a service_management parameter for this.","title":"Service management"},{"location":"Usage/service-management/#urls","text":"","title":"URLs"},{"location":"Usage/service-management/#add-service","text":"Method Path POST /service","title":"Add service"},{"location":"Usage/service-management/#description","text":"Adds a service to the database.","title":"Description"},{"location":"Usage/service-management/#body","text":"{ \"domain\" : \"string\" , \"name_service\" : \"string\" , \"port\" : 80 } domain - The domain of your service. It is mandatory to specify the protocol. For example, http://127.0.0.1 name_service - The name of the service. It must be unique. After specifying the name, the URL will look like this: https://127.0.0.1:80/{name_service}/... port - The port of the service. Failure You cannot specify the port in the domain. For example: http://127.0.0.1:8080 You need to specify them separately.","title":"Body"},{"location":"Usage/service-management/#response","text":"True if the addition was successful, otherwise False.","title":"Response"},{"location":"Usage/service-management/#example-python-requests","text":"# Install the Python Requests library: # `pip install requests` import requests def send_request (): # Request # POST http://127.0.0.1:5000/service try : response = requests . post ( url = \"http://127.0.0.1:5000/service\" , params = { \"ip\" : \"127.0.0.1\" , \"port\" : \"8080\" , \"name_service\" : \"Hello\" , }, ) print ( 'Response HTTP Status Code: {status_code} ' . format ( status_code = response . status_code )) print ( 'Response HTTP Response Body: {content} ' . format ( content = response . content )) except requests . exceptions . RequestException : print ( 'HTTP Request failed' )","title":"Example (Python requests)"},{"location":"Usage/service-management/#delete-service","text":"","title":"Delete service"},{"location":"Usage/service-management/#refresh-services","text":"Method Path PATCH /services","title":"Refresh services"},{"location":"Usage/service-management/#description_1","text":"Updates the URL and checks the functionality of the services without first restarting the program.","title":"Description"},{"location":"Usage/service-management/#example-python-requests_1","text":"# Install the Python Requests library: # `pip install requests` import requests def send_request (): # Request # PATCH http://127.0.0.1:5000/services try : response = requests . patch ( url = \"http://127.0.0.1:5000/services\" , ) print ( 'Response HTTP Status Code: {status_code} ' . format ( status_code = response . status_code )) print ( 'Response HTTP Response Body: {content} ' . format ( content = response . content )) except requests . exceptions . RequestException : print ( 'HTTP Request failed' )","title":"Example (Python requests)"},{"location":"Usage/service-management/#get-info-all-services","text":"","title":"Get info all services"},{"location":"Usage/tags_for_service/","text":"Tags for services \u00b6 Custom tags were added to configure the interaction with the API Gateway on the service side, which allow manipulation of the API Gateway. Tag Description x-auto-generate-in-api-gateway Pass the URL of the service to the API Gateway. x-enable-auth-in-api-gateway Enable or disable the protection that is automatically added by the API Gateway.","title":"Tags for service"},{"location":"Usage/tags_for_service/#tags-for-services","text":"Custom tags were added to configure the interaction with the API Gateway on the service side, which allow manipulation of the API Gateway. Tag Description x-auto-generate-in-api-gateway Pass the URL of the service to the API Gateway. x-enable-auth-in-api-gateway Enable or disable the protection that is automatically added by the API Gateway.","title":"Tags for services"},{"location":"Usage/using-as-module/","text":"Using as module \u00b6 Info This functionality has not yet been implemented","title":"Using as module"},{"location":"Usage/using-as-module/#using-as-module","text":"Info This functionality has not yet been implemented","title":"Using as module"},{"location":"Usage/FileManipulation/http-https/","text":"This method is suitable for transferring small files between the service and API-Gateway. If you plan to transfer files larger than 500 MB, it is recommended to consider using the method through a broker . File transfer to the service \u00b6 File retrieval from the services \u00b6 1. Service \u00b6 In this example, a service implemented through FastAPI will be used. If you have a service implemented in another programming language, the main requirement is to transfer the file in binary format with the header application/octet-stream . To pass a file through FastAPI, you can use FileResponse (more details can be found in the official documentation: https://fastapi.tiangolo.com/advanced/custom-response/#fileresponse ).\" Example of sending a file to an API Gateway: import os from fastapi.responses import FileResponse from fastapi import FastAPI , HTTPException , Cookie from pathlib import Path from collections import defaultdict processings = defaultdict ( dict ) temdir = Path ( '/tmp/files' ) app = FastAPI () @app . get ( \"/get_result\" , tags = [ \"default\" ]) async def get_result ( processing_id : str | None = Cookie ( default = None )): if not processing_id : HTTPException ( status_code = 400 , detail = \"Upload files first\" ) if not processing_id in processings : raise HTTPException ( status_code = 404 , detail = \"No such proc_id\" ) if not os . path . exists ( temdir / processing_id / 'out' ): raise HTTPException ( status_code = 425 , detail = \"Run processing first\" ) files = os . listdir ( temdir / processing_id / \"out\" ) files = [ f for f in files if f . endswith ( 'zip' )] out_file = temdir / processing_id / 'out' / files [ 0 ] return FileResponse ( out_file , filename = files [ 0 ], media_type = \"application/octet-stream\" ) 2. API-Gateway \u00b6 Bug It is not possible to download a file through Swagger, as when sending a request, the API-Gateway starts streaming byte streams, which can cause the page or the entire browser to crash. To solve the file download issue, you can either directly paste the URL in the browser, use some third-party tools, or use a programming language. An example of downloading and saving a file using Python: import requests cookies = { 'processing_id' : '0000000000000000001' } url = 'http://127.0.0.1:8080/service/get_result' r = requests . get ( url , allow_redirects = True , cookies = cookies ) if r . status_code == 200 : open ( 'save.zip' , 'wb' ) . write ( r . content )","title":"HTTP/HTTPS"},{"location":"Usage/FileManipulation/http-https/#file-transfer-to-the-service","text":"","title":"File transfer to the service"},{"location":"Usage/FileManipulation/http-https/#file-retrieval-from-the-services","text":"","title":"File retrieval from the services"},{"location":"Usage/FileManipulation/http-https/#1-service","text":"In this example, a service implemented through FastAPI will be used. If you have a service implemented in another programming language, the main requirement is to transfer the file in binary format with the header application/octet-stream . To pass a file through FastAPI, you can use FileResponse (more details can be found in the official documentation: https://fastapi.tiangolo.com/advanced/custom-response/#fileresponse ).\" Example of sending a file to an API Gateway: import os from fastapi.responses import FileResponse from fastapi import FastAPI , HTTPException , Cookie from pathlib import Path from collections import defaultdict processings = defaultdict ( dict ) temdir = Path ( '/tmp/files' ) app = FastAPI () @app . get ( \"/get_result\" , tags = [ \"default\" ]) async def get_result ( processing_id : str | None = Cookie ( default = None )): if not processing_id : HTTPException ( status_code = 400 , detail = \"Upload files first\" ) if not processing_id in processings : raise HTTPException ( status_code = 404 , detail = \"No such proc_id\" ) if not os . path . exists ( temdir / processing_id / 'out' ): raise HTTPException ( status_code = 425 , detail = \"Run processing first\" ) files = os . listdir ( temdir / processing_id / \"out\" ) files = [ f for f in files if f . endswith ( 'zip' )] out_file = temdir / processing_id / 'out' / files [ 0 ] return FileResponse ( out_file , filename = files [ 0 ], media_type = \"application/octet-stream\" )","title":"1. Service"},{"location":"Usage/FileManipulation/http-https/#2-api-gateway","text":"Bug It is not possible to download a file through Swagger, as when sending a request, the API-Gateway starts streaming byte streams, which can cause the page or the entire browser to crash. To solve the file download issue, you can either directly paste the URL in the browser, use some third-party tools, or use a programming language. An example of downloading and saving a file using Python: import requests cookies = { 'processing_id' : '0000000000000000001' } url = 'http://127.0.0.1:8080/service/get_result' r = requests . get ( url , allow_redirects = True , cookies = cookies ) if r . status_code == 200 : open ( 'save.zip' , 'wb' ) . write ( r . content )","title":"2. API-Gateway"},{"location":"Usage/FileManipulation/HTTP_HTTPS/FileRetrievalFromTheService/","text":"File retrieval from the services \u00b6 Service \u00b6 In this example, a service implemented through FastAPI will be used. If you have a service implemented in another programming language, the main requirement is to transfer the file in binary format with the header (application/octet-stream). To pass a file through FastAPI, you can use FileResponse (more details can be found in the official documentation: https://fastapi.tiangolo.com/advanced/custom-response/#fileresponse ).\" API-Gateway \u00b6 Bug It is not possible to download a file through Swagger, as when sending a request, the API-Gateway starts streaming byte streams, which can cause the page or the entire browser to crash. To solve the file download issue, you can either directly paste the URL in the browser, use some third-party tools, or use a programming language. An example of downloading and saving a file using Python: import requests cookies = { 'rinex_to_csv_processing_id' : '0000000000000000001' } url = 'http://127.0.0.1:8080/rinex/rinex_to_csv/get_result' r = requests . get ( url , allow_redirects = True , cookies = cookies ) if r . status_code == 200 : open ( 'save.zip' , 'wb' ) . write ( r . content )","title":"File retrieval from the services"},{"location":"Usage/FileManipulation/HTTP_HTTPS/FileRetrievalFromTheService/#file-retrieval-from-the-services","text":"","title":"File retrieval from the services"},{"location":"Usage/FileManipulation/HTTP_HTTPS/FileRetrievalFromTheService/#service","text":"In this example, a service implemented through FastAPI will be used. If you have a service implemented in another programming language, the main requirement is to transfer the file in binary format with the header (application/octet-stream). To pass a file through FastAPI, you can use FileResponse (more details can be found in the official documentation: https://fastapi.tiangolo.com/advanced/custom-response/#fileresponse ).\"","title":"Service"},{"location":"Usage/FileManipulation/HTTP_HTTPS/FileRetrievalFromTheService/#api-gateway","text":"Bug It is not possible to download a file through Swagger, as when sending a request, the API-Gateway starts streaming byte streams, which can cause the page or the entire browser to crash. To solve the file download issue, you can either directly paste the URL in the browser, use some third-party tools, or use a programming language. An example of downloading and saving a file using Python: import requests cookies = { 'rinex_to_csv_processing_id' : '0000000000000000001' } url = 'http://127.0.0.1:8080/rinex/rinex_to_csv/get_result' r = requests . get ( url , allow_redirects = True , cookies = cookies ) if r . status_code == 200 : open ( 'save.zip' , 'wb' ) . write ( r . content )","title":"API-Gateway"},{"location":"Usage/FileManipulation/HTTP_HTTPS/FileTransferToTheService/","text":"File transfer to the service \u00b6","title":"File transfer to the service"},{"location":"Usage/FileManipulation/HTTP_HTTPS/FileTransferToTheService/#file-transfer-to-the-service","text":"","title":"File transfer to the service"}]}